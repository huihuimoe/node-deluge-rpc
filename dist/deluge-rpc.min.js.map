{"version":3,"file":"deluge-rpc.min.js","sources":["../lib/index.js"],"sourcesContent":["const stream = require('stream')\nconst axios = require('axios')\nconst FormData = require('form-data')\nconst isNode = typeof stream !== 'undefined'\n\nmodule.exports = class DelugeRPC {\n  /**\n   * @constructor\n   * @param {string} delugeRpcBaseUrl deluge-web rpc url (without json)\n   * @param {string} rpcPassword deluge-web password\n   */\n  constructor (delugeRpcBaseUrl, rpcPassword) {\n    this.msgId = 0\n    this.cookie = ''\n    if (delugeRpcBaseUrl[delugeRpcBaseUrl.length - 1] !== '/') {\n      delugeRpcBaseUrl += '/'\n    }\n    this.baseUrl = delugeRpcBaseUrl\n    this.pass = rpcPassword\n  }\n\n  /**\n   * make request\n   * @param {string} method\n   * @param {Array<any>} [params=[]]\n   * @returns {Promise<Response>}\n   */\n  async _makeCall (method, params = []) {\n    if (this.msgId === 1024) {\n      this.msgId = 0\n    }\n    const headers = {\n      'Content-Type': 'application/json'\n    }\n    if (isNode) {\n      headers['Cookie'] = this.cookie\n    }\n    return axios.request({\n      url: this.baseUrl + 'json',\n      method: 'post',\n      data: {\n        method,\n        params,\n        id: this.msgId++\n      },\n      withCredentials: true,\n      headers\n    })\n  }\n\n  /**\n   * authorize\n   * @returns {Promise<boolean>}\n   */\n  async auth () {\n    const { data: { result: status } } = await this._makeCall('auth.check_session')\n    if (status) {\n      return true\n    }\n    const { data, headers } = await this._makeCall('auth.login', [this.pass])\n    if (!data.result) {\n      throw new Error('Auth failed, does the password valided?')\n    }\n    this.cookie = headers['set-cookie'][0].split(';')[0]\n    return true\n  }\n\n  /**\n   * call rpc method\n   * @param {string} method\n   * @param {Array<any>} [params=[]]\n   * @returns {Promise<any>}\n   */\n  async call (method, params = []) {\n    return this._makeCall(method, params).then(response => {\n      const data = response.data\n      if (data.error) {\n        throw data.error\n      }\n      return data.result\n    })\n  }\n\n  /**\n   * connect to a host\n   * @param {number | string} [host=0] index or the id of host\n   * @returns {Promise<null>}\n   */\n  async connect (host = 0) {\n    if (typeof host === 'number') {\n      const hosts = await this.call('web.get_hosts')\n      host = hosts[host][0]\n    }\n    const result = await this.call('web.connect', [host])\n    return result\n  }\n\n  /**\n   * get status of all torrents\n   * @returns {Promise<any>}\n   */\n  async getTorrentRecord () {\n    await this.auth()\n    return this.call('web.update_ui', [\n      [\n        'distributed_copies',\n        'download_payload_rate',\n        'eta',\n        'is_auto_managed',\n        'max_download_speed',\n        'max_upload_speed',\n        'name',\n        'num_peers',\n        'num_seeds',\n        'progress',\n        'queue',\n        'ratio',\n        'save_path',\n        'seeds_peers_ratio',\n        'state',\n        'time_added',\n        'total_done',\n        'total_peers',\n        'total_seeds',\n        'total_uploaded',\n        'total_wanted',\n        'tracker_host',\n        'upload_payload_rate'\n      ], {}\n    ])\n  }\n\n  /**\n   * add a torrent\n   * @param {string | URL | Buffer | Blob | Promise<string | URL | Buffer | Blob> } torrent - path or url or file\n   * @param {string | DelugeTorrentConfig} [config] - torrent options or download path\n   * @typedef {Object} DelugeTorrentConfig\n   * @prop {string} [cookie]\n   * @prop {Array<number>} [file_priorities=[]]\n   * @prop {boolean} [add_paused=false]\n   * @prop {boolean} [compact_allocation=true]\n   * @prop {number} [max_connections=-1]\n   * @prop {number} [max_download_speed=-1]\n   * @prop {number} [max_upload_slots=-1]\n   * @prop {number} [max_upload_speed=-1]\n   * @prop {boolean} [prioritize_first_last_pieces=false]\n   * @prop {string} [download_location]\n   * @returns {Promise<boolean>}\n   */\n  async addTorrent (torrent, config = {}) {\n    await this.auth()\n    if (torrent instanceof Promise) {\n      // fsPromises to Buffer\n      torrent = await torrent\n    }\n\n    let form\n    // node env\n    if (isNode &&\n      (torrent instanceof Buffer || torrent instanceof stream.Readable)\n    ) {\n      form = new FormData()\n      form.append('file', torrent, 'upload.torrent')\n    }\n    // browser env\n    if (!isNode &&\n      (torrent instanceof File || torrent instanceof Blob)\n    ) {\n      form = new FormData()\n      form.append('file', torrent, torrent.name || 'upload.torrent')\n    }\n    // upload torrent\n    if (form) {\n      const headers = {\n        ...form.getHeaders()\n      }\n      if (isNode) {\n        headers['Cookie'] = this.cookie\n      }\n      const result = await axios.request({\n        url: this.delugeRpcBaseUrl + 'upload',\n        method: 'post',\n        data: form,\n        withCredentials: true,\n        headers\n      })\n      torrent = result['files'][0]\n    }\n\n    if (typeof config === 'string') {\n      config = {\n        download_location: config\n      }\n    }\n\n    // a URL\n    let isURL = false\n    try {\n      isURL = !!new URL(torrent)\n    } catch (e) {}\n    if (isURL) {\n      torrent = await this.call('web.download_torrent_from_url', [torrent, config.cookie])\n      delete config.cookie\n    }\n\n    config = {\n      path: torrent,\n      options: {\n        file_priorities: [],\n        add_paused: false,\n        compact_allocation: true,\n        max_connections: -1,\n        max_download_speed: -1,\n        max_upload_slots: -1,\n        max_upload_speed: -1,\n        prioritize_first_last_pieces: false,\n        ...config\n      }\n    }\n\n    const result = await this.call('web.add_torrents', [[config]])\n    return result\n  }\n}\n"],"names":["isNode","stream","[object Object]","delugeRpcBaseUrl","rpcPassword","this","msgId","cookie","length","baseUrl","pass","method","params","headers","Content-Type","axios","request","url","data","id","withCredentials","result","status","_makeCall","Error","split","then","response","error","host","call","auth","torrent","config","form","Promise","Buffer","Readable","FormData","append","File","Blob","name","getHeaders","download_location","isURL","URL","e","path","options","file_priorities","add_paused","compact_allocation","max_connections","max_download_speed","max_upload_slots","max_upload_speed","prioritize_first_last_pieces"],"mappings":"+bAGA,MAAMA,OAA2B,IAAXC,SAEL,MAMfC,YAAaC,EAAkBC,GAC7BC,KAAKC,MAAQ,EACbD,KAAKE,OAAS,GACwC,MAAlDJ,EAAiBA,EAAiBK,OAAS,KAC7CL,GAAoB,KAEtBE,KAAKI,QAAUN,EACfE,KAAKK,KAAON,EASdF,gBAAiBS,EAAQC,EAAS,IACb,OAAfP,KAAKC,QACPD,KAAKC,MAAQ,GAEf,MAAMO,EAAU,CACdC,eAAgB,oBAKlB,OAHId,IACFa,EAAgB,OAAIR,KAAKE,QAEpBQ,EAAMC,QAAQ,CACnBC,IAAKZ,KAAKI,QAAU,OACpBE,OAAQ,OACRO,KAAM,CACJP,OAAAA,EACAC,OAAAA,EACAO,GAAId,KAAKC,SAEXc,iBAAiB,EACjBP,QAAAA,IAQJX,aACE,MAAQgB,MAAQG,OAAQC,UAAmBjB,KAAKkB,UAAU,sBAC1D,GAAID,EACF,OAAO,EAET,MAAMJ,KAAEA,EAAIL,QAAEA,SAAkBR,KAAKkB,UAAU,aAAc,CAAClB,KAAKK,OACnE,IAAKQ,EAAKG,OACR,MAAM,IAAIG,MAAM,2CAGlB,OADAnB,KAAKE,OAASM,EAAQ,cAAc,GAAGY,MAAM,KAAK,IAC3C,EASTvB,WAAYS,EAAQC,EAAS,IAC3B,OAAOP,KAAKkB,UAAUZ,EAAQC,GAAQc,KAAKC,IACzC,MAAMT,EAAOS,EAAST,KACtB,GAAIA,EAAKU,MACP,MAAMV,EAAKU,MAEb,OAAOV,EAAKG,SAShBnB,cAAe2B,EAAO,GAMpB,MALoB,iBAATA,IAETA,SADoBxB,KAAKyB,KAAK,kBACjBD,GAAM,UAEAxB,KAAKyB,KAAK,cAAe,CAACD,IAQjD3B,yBAEE,aADMG,KAAK0B,OACJ1B,KAAKyB,KAAK,gBAAiB,CAChC,CACE,qBACA,wBACA,MACA,kBACA,qBACA,mBACA,OACA,YACA,YACA,WACA,QACA,QACA,YACA,oBACA,QACA,aACA,aACA,cACA,cACA,iBACA,eACA,eACA,uBACC,KAqBP5B,iBAAkB8B,EAASC,EAAS,IAOlC,IAAIC,EAgBJ,SAtBM7B,KAAK0B,OACPC,aAAmBG,UAErBH,QAAgBA,GAKdhC,IACDgC,aAAmBI,QAAUJ,aAAmB/B,EAAOoC,YAExDH,EAAO,IAAII,GACNC,OAAO,OAAQP,EAAS,mBAG1BhC,IACFgC,aAAmBQ,MAAQR,aAAmBS,QAE/CP,EAAO,IAAII,GACNC,OAAO,OAAQP,EAASA,EAAQU,MAAQ,kBAG3CR,EAAM,CACR,MAAMrB,EAAU,IACXqB,EAAKS,cAEN3C,IACFa,EAAgB,OAAIR,KAAKE,QAS3ByB,SAPqBjB,EAAMC,QAAQ,CACjCC,IAAKZ,KAAKF,iBAAmB,SAC7BQ,OAAQ,OACRO,KAAMgB,EACNd,iBAAiB,EACjBP,QAAAA,KAEsB,MAAE,GAGN,iBAAXoB,IACTA,EAAS,CACPW,kBAAmBX,IAKvB,IAAIY,GAAQ,EACZ,IACEA,IAAU,IAAIC,IAAId,GAClB,MAAOe,IAsBT,OArBIF,IACFb,QAAgB3B,KAAKyB,KAAK,gCAAiC,CAACE,EAASC,EAAO1B,gBACrE0B,EAAO1B,QAGhB0B,EAAS,CACPe,KAAMhB,EACNiB,QAAS,CACPC,gBAAiB,GACjBC,YAAY,EACZC,oBAAoB,EACpBC,iBAAkB,EAClBC,oBAAqB,EACrBC,kBAAmB,EACnBC,kBAAmB,EACnBC,8BAA8B,KAC3BxB,UAIc5B,KAAKyB,KAAK,mBAAoB,CAAC,CAACG"}